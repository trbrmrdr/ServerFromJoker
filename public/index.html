<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/@mdi/font@5.x/css/materialdesignicons.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/vuetify@2.x/dist/vuetify.min.css" rel="stylesheet">
  <link href="http://selfthinker.github.io/CSS-Playing-Cards/cards.css" rel="stylesheet">
  <link href="/public/styles.css" rel="stylesheet">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui">
  <title>Joker Game</title>
</head>

<body>
  <div id="app">
    <layout></layout>
  </div>
  
  <script src="https://unpkg.com/vue/dist/vue.js"></script>
  <script src="https://unpkg.com/vuex"></script>
  <script src="https://unpkg.com/vue-router/dist/vue-router.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vuetify@2.x/dist/vuetify.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/superagent/4.1.0/superagent.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.20.3/TweenMax.min.js"></script>
  <script src="/magx" type="text/javascript"></script>

  <script type="text/x-template" id="layout">
    <v-app >
      <div v-if="token">
        <appbar></appbar>
        <v-main>
          <v-container class="px-4 py-0 fill-height" fluid>
            <v-row class="fill-height">
              <v-col>
                <transition name="fade">
                  <router-view></router-view>
                </transition>
              </v-col>
            </v-row>
          </v-container>
        </v-main>
      </div>
      <div v-else> 
        <login></login>
      </div>
      <loader></loader>
      <error></error>
    </v-app>
  </script>
  <script id="layout">
    const Layout = {
      template: "#layout",
      computed: {
        ...Vuex.mapState(["token"]),
      },
      mounted() {
        const token = sessionStorage.getItem("token")
        return this.$store.dispatch("verifyToken", token)
      }
    }
  </script>

  <script type="text/x-template" id="appbar">
    <v-app-bar app color="primary" dark elevation="0">
      <v-app-bar-nav-icon @click.stop="toggleSideBar" class="hidden-md-and-up"></v-app-bar-nav-icon>
      <v-spacer></v-spacer>
      <v-btn @click="logout" color="secondary" class="mr-2"><v-icon>mdi-logout</v-icon><span class="hidden-sm-and-down">Выход</span></v-btn>

    </v-app-bar>
  </script>
  <script id="appbar">
    const AppBar = {
      template: "#appbar",
      methods: {
        ...Vuex.mapActions(["toggleSideBar", "logout"])
      }
    }
  </script>

  <script type="text/x-template" id="login">
    <v-dialog v-model="loginDialog" max-width="290" persistent>
      <v-card>
        <v-card-title class="headline">
          Вход
        </v-card-title>

        <v-card-text>
          <v-container fluid>
            <v-row>
              <v-text-field
                v-model="id"
                name="id"
                label="Введите ваш id"
              ></v-text-field>
            </v-row>
          </v-container>  
        </v-card-text>
        <v-card-actions>
          <v-spacer></v-spacer>
          <v-btn color="green darken-1" :disabled="!id" text @click="login" >
            Войти
          </v-btn>
          <v-spacer></v-spacer>
        </v-card-actions>
      </v-card>
    </v-dialog>
  </script>
  <script id="login">
  const Login = {
    template: '#login',
    data: () => ({
      id: "",
      show: false
    }),
    computed: {
      token() { return this.$store.state.token },
      loginDialog: {
        get() { return !this.token },
        set(value) { }
      },
    },
    methods: {
      async login() {
        try {
          await this.$store.dispatch("authenticate", this.id)
        } catch (error) {
          console.log(error)
        }
      }
    }
  }
  </script>

  <script type="text/x-template" id="error">    
    <v-snackbar v-model="errorMessage" timeout="3000">
      {{ error }}
      <template v-slot:action="{ attrs }">
        <v-btn
          color="blue"
          text
          v-bind="attrs"
          @click="snackbar = false"
        >
          Close
        </v-btn>
      </template>
    </v-snackbar>
  </script>
  <script id="error">
    const ErrorMessage = {
      template: '#error',
      computed: {
        error() { return this.$store.state.error },
        errorMessage: {
          get() { return !!this.error },
          set(value) { this.$store.commit("setError", "") }
        }
      }
    }
  </script>

  <script type="text/x-template" id="main">    
    <v-container>
      <v-btn to="/game/create">
        Создать комнату
      </v-btn>
      <v-list three-line>
        <template v-for="(room, index) in rooms">
          <v-list-item :key="room.roomId" @click="joinRoom(room)">
            <v-list-item-content>
              <v-list-item-title v-html="room.name + ': ' + room.options.name"></v-list-item-title>
              <v-list-item-subtitle v-html="room"></v-list-item-subtitle>
            </v-list-item-content>
          </v-list-item>
        </template>
      </v-list>
    </v-container>
  </script>
  <script id="main">
    const Main = {
      template: '#main',
      computed: {
        rooms() { return this.$store.getters.rooms },
      },
      methods: {
        joinRoom(room) { 
          console.log('join room', room)
        },
      }
    }
    
  </script>

  <script type="text/x-template" id="deck">    
    <div class="card-slot">
      <ul :id="board.props.deck" class="deck">
        <li v-for="card in deck" :key="card.id">
          <card :data="card" />
        </li>
      </ul>
    </div>
  </script>
  <script id="deck">
    const Deck = {
      template: '#deck',
      data: () => ({
        cards: []
      }),
      computed: {
        board() { return this.$store.getters.board },
        deck() { return this.$store.getters.deck },
        inShuffle() { return this.board && this.$store.getters.object(this.board.deckId).inShuffle }
      },
      watch: {
        inShuffle(value) {
          if (value) {
            setTimeout(() => {
              this.cards = [...this.$el.children[0].children]
              this.cards.forEach(el => {
                const card = this.$store.getters.object(el.children[0].id)
                const rect = el.getBoundingClientRect()
                this.$store.commit("setObjectPos", { id: card.id, pos: { x: rect.left, y: rect.top }})
              })
              this.animateRandomCard()
            }, 100)
          }
        }
      },
      mounted() {
        this.cards = [...this.$el.children[0].children]
        this.animateRandomCard()
      },
      methods: {
        animateRandomCard() {
          if (this.inShuffle && this.cards.length) {
            // select random card
            const index = Math.floor(Math.random() * this.cards.length)
            const card = this.cards.splice(index, 1)[0]
            
            // animate card
            TweenMax.to(card, 0.2, { 
              x: Math.floor(Math.random() * 3 - 1) * 80, 
              y: Math.floor(Math.random() * 3 - 1) * 120, 
              repeat: 1, 
              yoyo: true, 
              onComplete: () => this.cards.push(card)
            })
  
            // animate next card
            setTimeout(() => this.animateRandomCard(), 60)
          }
        }
      }
    }
  </script>

  <script type="text/x-template" id="card">    
    <component :id="data.id" :is="cardRank && tag || 'div'" class="card" :style="style" :class="cardClass" href="#">
      <span class="rank" v-if="cardRank">{{ cardRank }}</span>
      <span class="suit" v-if="cardRank">{{ cardSuit }}</span>
      {{ !cardRank && "*" || "" }}
    </component>
  </script>
  <script id="card">
    const Card = {
      template: '#card',
      props: ['data', 'tag'],
      computed: {
        style() { return this.data.style || "" },
        face() { return this.data.face || this.data.data || { value: 0  } },
        cardClass() { return this.face.value && ["rank-" + this.face.value.toLowerCase(), suit(this.face.suit)] || "back" },
        cardRank() { return this.face.value },
        cardSuit() { return suitCode(this.face.suit) },
      },
      mounted() { !this.data.pos && this.updatePos() },
      // update card pos when window resized
      created() { window.addEventListener("resize", this.updatePos) },
      destroyed() { window.removeEventListener("resize", this.updatePos) },
      methods: {
        updatePos() {
          const rect = this.$el.getBoundingClientRect()
          this.$store.commit("setObjectPos", { id: this.data.id, pos: { x: rect.left, y: rect.top }})
        }
      }
    }
    
  </script>

  <script type="text/x-template" id="player-board">    
    <div class="player-board" :class="tag">
      <div id="title" class="text-center title" :class="tag">
        <v-btn rounded color="green" dark>{{ player.user.name }}</v-btn>
        <v-icon v-if="!player.connected">mdi-wifi-off</v-icon>
      </div>
      <div class="card-slot trash" :class="tag">
        <ul :id="player.trashId" class="deck" style="height: 0px">
          <transition-group @enter="animateSlotEnter">
            <li v-for="card in playerTrash" :key="card.id">
              <card :data="card" style="opacity: 0" />
            </li>
          </transition-group>
        </ul>
      </div>
      <div class="card-slot" :class="tag" :style="transform + '; ' + center">
        <ul :id="player.handId" :class="pos ? 'hand' : 'hand my'">
          <transition-group @enter="animateSlotEnter">
            <li v-for="card in playerHand" :key="card.id" @click="play(player.id, card.id)">
              <card :data="card" :tag="cardAction(card.id) && 'a'"/>
            </li>
          </transition-group>
        </ul>
      </div>
      <div :id="player.cardSlotId" class="card-slot" :class="otag">
        <transition @enter="animateEnter">
          <card v-if="card" :data="card" />
        </transition>
      </div>
      <div v-if="timer >= 1" class="timer" :class="timerPos">
        <v-progress-circular
          :rotate="-90"
          :size="50"
          color="teal"
          :value="timer/maxTimer*100"
        >
          {{ timer }}
        </v-progress-circular>
      </div>
      <div  v-if="player.suit >= 0" class="player-suit">
        <v-avatar :color="color" size="48">
          <span class="white--text headline">{{ suitCode }}</span>
        </v-avatar>
      </div>
    </div>
  </script>
  <script id="player-board">
    const PlayerBoard = {
      template: '#player-board',
      data: () => ({
        maxTimer: -1
      }),
      props: ['player', 'pos'],
      computed: {
        cardAction() { return this.$store.getters.cardAction },
        playerHand() { return this.$store.getters.playerHand(this.player) },
        playerTrash() { return this.$store.getters.playerTrash(this.player) },
        suitCode() { return suitCode(this.player.suit) },
        card() { 
          const slot = this.$store.getters.playerCard(this.player)
          return slot.length && slot[0]
        },
        timer() { return this.$store.getters.timer(this.player.timerId) },
        tag() {
          return ['bottom', 'left', 'top', 'right'][this.pos]
        },
        otag() {
          return ['top', 'right', 'bottom', 'left'][this.pos]
        },
        timerPos() {
          return ['right h40', '', 'right h25', 'right'][this.pos]
        },
        color() {
          return this.player.suit > 1 ? 'red' : 'black'  
        },
        transform() {
          return ['transform: scale(1.5);', 'transform: rotate(0deg)', '', 'transform: rotate(-0deg)'][this.pos]
        },
        center() {
          const num = this.playerHand.length
          return ["right: " + num * 35 + "px", "", "", ""][this.pos]
        }
      },
      watch: {
        timer(value) {
          this.maxTimer = Math.max(this.maxTimer, value)
        }
      },
      methods: {
        play(playerId, cardId) { this.$store.dispatch("playerAction", { playerId, cardId }) },
        animateEnter(el, done) {
          const card = this.$store.getters.object(el.id)
          const rect = el.getBoundingClientRect()
          TweenMax.from(el, 0.5, { x: card.pos.x - rect.left, y: card.pos.y - rect.top, rotation: 180, opacity: 1, onComplete: done })
          this.$store.commit("setObjectPos", { id: card.id, pos: { x: rect.left, y: rect.top }})
        },
        animateSlotEnter(el, done) { this.animateEnter(el.firstChild, done) }
      }
    }
  </script>

  <script type="text/x-template" id="loader">
    <v-dialog v-model="loading" persistent width="120">
      <v-card>
        <v-card-text class="text-xs-center">
          <v-progress-circular :size="70" indeterminate class="secondary--text"/>
        </v-card-text>
      </v-card>
    </v-dialog>
  </script>
  <script id="loader">
    const Loader = {
      template: "#loader",
      computed: {
        loading: {
          get() { return this.$store.state.loading },
          set(value) { this.$store.commit("setLoading", value) }
        }
      }
    }
  </script>

  <script type="text/x-template" id="gameLayout">    
    <div id="game-table" class="playingCards faceImages">
      <div class="game-board">
        <deck v-if="board.scene !== 'initGame'"></deck>
        <div class="game-trump">
          <span class="suit"></span>
        </div>
      </div>
      <player-board v-for="(player, index) in playersList" :key="player.id" :player="player" :pos="index"></player-board>
    </div>
  </script>
  <script id="gameLayout">
    const MIN_WIDTH = 550;
    const MAX_WIDTH = 1500;
    const MIN_HEIGHT = 750;
    const MAX_HEIGHT = 1100;

    const GameLayout = {
      template: '#gameLayout',
      computed: {
        ...Vuex.mapGetters([
          "playersList", "board", "me"
        ])
      },
      methods: {
        resize() {
          // get parent element size
          const { clientWidth: width, clientHeight: height } = this.$el.parentElement
          
          // calculate scale for width & height 
          let scaleX = width / (width < MIN_WIDTH && MIN_WIDTH || width > MAX_WIDTH && MAX_WIDTH || width)
          let scaleY = height / (height < MIN_HEIGHT && MIN_HEIGHT || height > MAX_HEIGHT && MAX_HEIGHT || height)
        
          // adjust scale for width and height
          scaleX = Math.min(scaleX, height / MIN_HEIGHT)
          scaleY = Math.min(scaleY, width / MIN_WIDTH)
          
          // select scale
          const scale = Math.abs(scaleX - 1) > Math.abs(scaleY - 1) ? scaleX : scaleY

          // calculate scaled width & height
          var elWidth = Math.min(Math.max(width / scale, MIN_WIDTH), MAX_WIDTH)
          var elHeight = Math.min(Math.max(height / scale, MIN_HEIGHT), MAX_HEIGHT)

          // update #game-table inline style
          const { style } = this.$el
          style.width = scale !== 1 && elWidth + "px" || "",
          style.height = scale !== 1 && elHeight + "px" || "",
          style.transform = scale !== 1 && "scale(" + scale + ")" || ""
        },
      },
      mounted() {
        window.addEventListener("resize", this.resize)
        this.resize()
      },
    }
  </script>

  <script type="text/x-template" id="createGame">    
    <v-container>
     <h1>Создать стол</h1>
     <v-row>
       
     </v-row>

    </v-container>
  </script>
  <script id="createGame">
    const CreateGame = {
      template: '#createGame',
      data: () => ({
        dialog: false,
        password: '',
        error: false,
      }),
      computed: {
        loading() { return this.$store.getters.loading },
      },
      methods: {
       
      }
    }
  </script>

  <script id="magx">

    const { host, port, protocol } = window.document.location
    var client = new MagX.Client({ address: host.replace(/:.*/, ''), port, secure: protocol === "https:" })

    const suit = suitId => (["spades", "clubs", "hearts", "diams"][suitId] || "")
    const suitCode = suitId => (["\u2660", "\u2663", "\u2665", "\u2666"][suitId] || "")
  </script>

  <script id="store">
  
    let settings = {
      waitTime: 30,
      turnTime: 30,
      reconnectionTimeout: 30,
      reconnectionLimit: 5,
      reconnectionDelay: 15
    }

    const store = new Vuex.Store({
      strict: true,
      state: {
        error: "",
        loading: false,
  
        token: "",
        // state from patches
        clients: {},
        objects: {},
        boardId: "",
        // meta for objects data
        meta: {},
        // from client
        clientId: "",
        // from room
        roomId: "",
        send: null,
        leave: null,
        rooms: [],
      },
      getters: {
        // get object by id
        object: ({ objects }) => (id) => objects[id] || null,
        // get meta by id
        objectMeta: ({ meta }) => (id) => meta[id] || null,

        // get property object
        objectProp: ({ }, { object }) => (obj, id) => obj && object(obj.props[id]) || null,

        // get list of items id
        objectItems: ({ }, { object }) => (id) => object(id) && object(id).items || [],
        // get list of items objects
        objectItemsObject: ({ }, { objectItems, object }) => (id) => objectItems(id).map(itemId => object(itemId)),

        // get client's player
        me: ({ clients, clientId }, { object }) => clientId && object(clients[clientId]) || null,
        // get board
        board: ({ boardId }, { object }) => object(boardId),
        // get list of players
        players: ({ clients, objects }, { object, board }) => {
          return Object.values(objects).filter((o) => o.type === "JokerPlayer").sort((a,b) => a.index - b.index)
        },
      },
      mutations: {
        setLoading(state, value) { state.loading = value },
        setError(state, value) { state.error = value },
        setToken(state, value) { state.token = value },
        setRoom(state, room) {
          state.clientId = room.client.auth.id
          state.roomId = room.id
          state.leave = () => room.leave()
          state.send = (type, data) => room.send(type, data)
        },
        setRooms(state, rooms) { state.rooms = rooms },
        updateRoom(state, { roomId, data }) {
          const index = state.rooms.findIndex((room) => room.id === roomId)
          if (data === null) {
            state.rooms.splice(index, 1)
          } else {
            if (index >= 0) {
              Vue.set(state.rooms, index, data)
            } else {
              state.rooms.push(data)
            }
          }
        },
        setState(state, snapshot) {
          Object.keys(snapshot).forEach((key) => Vue.set(state, key, snapshot[key]))
        },
        add(state, { value, key, path }) {
          let obj = state
          path.forEach(id => obj = obj[id])
          if (Array.isArray(obj) && +key) {
            obj.splice(+key, 0, value)
          } else {
            Vue.set(obj, key, value) // set value
          }
        },
        replace(state, { value, key, path }) {
          let obj = state
          path.forEach(id => obj = obj[id])
          if (Array.isArray(obj) && +key) {
            Vue.set(obj, +key, value) // update array value
          } else {
            Vue.set(obj, key, value) // update object value
          }
        },
        remove(state, { path, key }) {
          let obj = state
          path.forEach(id => obj = obj[id])
          if (Array.isArray(obj) && +key) {
            obj.splice(+key, 1)
          } else {
            Vue.delete(obj, key)
          }
        },
      },
      actions: {
        async verifyToken({ commit, dispatch }, token) {
          if (!token) { return }
          commit("setLoading", true)
          try {
            console.log("verify token", token)
            const auth = await client.verify(token)
            commit("setToken", auth ? token : "")
            commit("setLoading", false)
            return dispatch("joinLobby")
          } catch (error) {
            commit("setToken", "")
            commit("setLoading", false)
          }
        },
        async authenticate({ commit, dispatch }, id) {
          commit("setLoading", true)
          try {
            const auth = await client.authenticate({ id })
            console.log("authenticate", auth)
            commit("setToken", auth.token)
            // commit("setProfile", auth.data)
            sessionStorage.setItem("token", auth.token)
            commit("setLoading", false)
            return dispatch("joinLobby")
          } catch (error) {
            console.log("Error", error)
            commit("setToken", "")
            commit("setLoading", false)
          }
        },
        async joinLobby({ commit, dispatch }) {
          commit("setLoading", true)
          try {
            const rooms = await client.getRooms("jokerLobby")
            const lobby = rooms.length ? await client.joinRoom(rooms[0].id) : await client.createRoom("jokerLobby")
          
            console.log("joind lobby")
            return dispatch("initLobbyHandlers", lobby)
          } catch (error) {
            commit("setLoading", false)
            console.log("Error", error)
          }
        },
        initLobbyHandlers({ commit, dispatch }, lobby) {
          lobby.onMessage("rooms", async (roomsList) => {
            commit("setRooms", roomsList)
          })
          lobby.onMessage("room_update", async (update) => {
            commit("updateRoom", update)
          })
          lobby.onMessage("error", async (data) => {
            console.log(data)
          })
          commit("setLoading", false)
        },
        /** 
         * server events
        */

        addBot({ state }) {
          state.send("addbot")
        },

        execAction({ state, getters, commit }, actionId) {
          commit("setMeta", { id: getters.board.id, data: { selectedCardId: null } })
          state.send("action", { actionId })
        },

        send({ state }, { type, data }) {
          state.send(type, data)
        },

        async leave({ state }) {
          state.send("surrender")
        },

        /**
         * Animation
        */
        animate({ state, commit }, { el, x, y, r, done }) {
          const meta = state.meta[el.id]
          if (!meta) { return }
          r = r || 180
          if (Math.abs(meta.x - x) + Math.abs(meta.y - y) > 100) {
            r = 0
            TweenMax.from(el, 0.5, { x: meta.x - x, y: meta.y - y, rotation: r, opacity: 1, onComplete: done })
          }
          commit("setMeta", { id: el.id, data: { x, y } })
        },

        /**
         * Magx API
        */

        async createRoom({ dispatch }, { options }) {
          room = await client.createRoom('joker', options)
          await dispatch("initRoomHandlers", room)
        },

        async joinRoom({ dispatch }, { roomId, password }) {
          room = await client.joinRoom(roomId, { password })
          dispatch("initRoomHandlers", room)
        },

        async reconnect({ dispatch }, { roomId, sessionId }) {
          const timer = setTimeout(() => {
            Promise.reject()
          }, 1000)
          room = await client.reconnect(roomId)
          clearTimeout(timer)
          dispatch("initRoomHandlers", room)
        },
        // init room handlers
        initRoomHandlers({ commit, dispatch }, room) {
          commit("setRoom", room)

          // save roomId
          sessionStorage.setItem('roomId', room.id)

          // handle messages from server
          room.onMessage("log", (data) => {
            console.log(data)
          })

          room.onPatch(({ op, value, path }) => {
            // console.log("onPatch", { op, value, path })
            path = path.substr(1).split("/")
            commit(op, { value, key: path.pop(), path })
          })

          room.onSnapshot((snapshot) => {
            // console.log("onSnapshot", snapshot)
            commit("setState", snapshot)
          })

          room.onLeave(() => {
            // TODO
          })
        }
      }
    })
  </script>

  <script id="router">
    const router = new VueRouter({
      mode: "history",
      routes: [
        { path: '/', component: Main },
        { path: '/game/create', component: CreateGame },
        { path: '/game/:id', component: GameLayout, props: true },
      ]
    })
  </script>

  <script id="vue">
    Vue.component('appbar', AppBar)
    Vue.component('loader', Loader)
    Vue.component('layout', Layout)
    Vue.component('login', Login)
    Vue.component('error', ErrorMessage)

    Vue.component('deck', Deck)
    Vue.component('card', Card)
    Vue.component('player-board', PlayerBoard)

    new Vue({
      el: '#app',
      router,
      store,
      vuetify: new Vuetify({
        theme: {
          themes: {
            light: {
              primary: "#388E3C", // "green darken-2"
              secondary: "#512DA8", // "deep-purple darken-2"
              accent: "#FFD600", // "yellow accent-4"
            },
          },
        },
      }),
    })
  </script>

</body>

</html>