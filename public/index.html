<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  <meta charset="UTF-8">
  <!-- <link href="/public/css/fonts.css" rel="stylesheet"> -->
  <!-- <link href="/public/css/icons.css" rel="stylesheet"> -->
  <link href="/public/css/vuetify.css" rel="stylesheet">
  <link href="/public/css/cards.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/@mdi/font@5.x/css/materialdesignicons.min.css" rel="stylesheet">
  <!-- <link href="https://cdn.jsdelivr.net/npm/vuetify@2.x/dist/vuetify.min.css" rel="stylesheet">
  <link href="http://selfthinker.github.io/CSS-Playing-Cards/cards.css" rel="stylesheet"> -->
  <link href="/public/css/styles.css" rel="stylesheet">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui">
  <title>Joker Game</title>
</head>

<body>
  <div id="app">
    <layout></layout>
  </div>
  
  <!-- <script src="/public/js/vue.js"></script>
  <script src="/public/js/vuex.js"></script>
  <script src="/public/js/vue-router.js"></script>
  <script src="/public/js/vuetify.js"></script>
  <script src="/public/js/superagent.js"></script>
  <script src="/public/js/tweenmax.js"></script> -->
  <script src="https://unpkg.com/vue/dist/vue.js"></script>
  <script src="https://unpkg.com/vuex"></script>
  <script src="https://unpkg.com/vue-router/dist/vue-router.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vuetify@2.x/dist/vuetify.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/superagent/4.1.0/superagent.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.20.3/TweenMax.min.js"></script>
  <script src="/magx" type="text/javascript"></script>

  <script type="text/x-template" id="layout">
    <v-app >
      <appbar></appbar>

      <router-view></router-view>

      <loader></loader>
      <error></error>
    </v-app>
  </script>
  <script id="layout">
    const Layout = {
      template: "#layout",
    }
  </script>

  <script type="text/x-template" id="appbar">
    <v-app-bar color="primary" dark elevation="0" style="max-height: 64px">
      <v-spacer></v-spacer>
      <v-btn @click="logout" color="secondary" class="mr-2" v-if="token">
        <v-icon>mdi-logout</v-icon>
        <span class="hidden-sm-and-down">Выход</span>
      </v-btn>

    </v-app-bar>
  </script>
  <script id="appbar">
    const AppBar = {
      template: "#appbar",
      computed: Vuex.mapState(["token"]),
      methods: Vuex.mapActions(["logout"])
    }
  </script>

  <script type="text/x-template" id="login">

      <v-card class="mx-auto my-12" max-width="500">
        <v-card-title class="headline">
          Вход
        </v-card-title>

        <v-card-text>
          <v-container fluid>
            <v-row>
              <v-text-field
                v-model="id"
                name="id"
                label="Введите ваш id"
              ></v-text-field>
            </v-row>
          </v-container>  
        </v-card-text>
        <v-card-actions>
          <v-spacer></v-spacer>
          <v-btn color="green darken-1" :disabled="!id" text @click="login" >
            Войти
          </v-btn>
          <v-spacer></v-spacer>
        </v-card-actions>
      </v-card>

  </script>
  <script id="login">
  const Login = {
    template: '#login',
    data: () => ({
      id: "",
    }),
    computed: {
      token() { return this.$store.state.token },
    },
    methods: {
      async login() {
        try {
          await this.$store.dispatch("authenticate", this.id)
          if (this.token) {
            this.$router.push({ path: "/" })
          }
        } catch (error) {
          console.log(error)
        }
      }
    }
  }
  </script>

  <script type="text/x-template" id="error">    
    <v-snackbar v-model="errorMessage" timeout="3000">
      {{ error }}
      <template v-slot:action="{ attrs }">
        <v-btn
          color="blue"
          text
          v-bind="attrs"
          @click="snackbar = false"
        >
          Close
        </v-btn>
      </template>
    </v-snackbar>
  </script>
  <script id="error">
    const ErrorMessage = {
      template: '#error',
      computed: {
        error() { return this.$store.state.error },
        errorMessage: {
          get() { return !!this.error },
          set(value) { this.$store.commit("setError", "") }
        }
      }
    }
  </script>

  <script type="text/x-template" id="main">    
    <v-container>
      <v-btn to="/game/create">
        Создать комнату
      </v-btn>
      <v-list three-line>
        <template v-for="(room, index) in rooms">
          <v-list-item :key="room.roomId" @click="joinRoom(room)">
            <v-list-item-content>
              <v-list-item-title v-html="room.name"></v-list-item-title>
              <v-list-item-subtitle v-html="room"></v-list-item-subtitle>
            </v-list-item-content>
          </v-list-item>
        </template>
      </v-list>
    </v-container>
  </script>
  <script id="main">
    const Main = {
      template: '#main',
      computed: {
        rooms() { return this.$store.state.rooms },
      },
      methods: {
        async joinRoom(room) { 
          console.log('join room', room)
          await this.$store.dispatch("joinRoom", { roomId: room.id })
          const roomId = this.$store.state.roomId
          if (roomId) {
            this.$router.push({ path: `/game/${roomId}`})
          }
        },
      }
    }
  </script>

  <script type="text/x-template" id="deck">    
    <div class="card-slot">
      <ul :id="board.props.deck" class="deck">
        <transition-group @enter="updateMeta">
          <li v-for="card in deck" :key="card.id">
            <card :data="card" />
          </li>
        </transition-group>
      </ul>
    </div>
  </script>
  <script id="deck">
    const Deck = {
      template: '#deck',
      data: () => ({
        cards: []
      }),
      computed: {
        board() { return this.$store.getters.board },
        deck() { return this.$store.getters.objectItemsObject(this.board.props.deck) || [] },
      },
      methods: {
        updateMeta(el, done) {
          const { left, top } = el.firstChild.getBoundingClientRect()
          console.log("Move card to deck", el.firstChild.id)
          // this.$store.dispatch("animate", { el: el.firstChild, x: left, y: top, r: 180, done })
          this.$store.commit("setMeta", { id: el.firstChild.id, data: { x: left, y: top } })
        }
      }
    }
  </script>

  <script type="text/x-template" id="trump-slot">    
    <div class="card-slot">
      <ul :id="board.props.trumpSlot" class="deck">
        <li v-for="card in trumpSlot" :key="card.id">
          <card :data="card" />
        </li>
      </ul>
    </div>
  </script>
  <script id="trump-slot">
    const TrumpSlot = {
      template: '#trump-slot',
      computed: {
        board() { return this.$store.getters.board },
        trumpSlot() { return this.$store.getters.objectItemsObject(this.board.props.trumpSlot) || [] },
      }
    }
  </script>

  <script type="text/x-template" id="card">    
    <component :id="data.id" :is="cardRank && tag || 'div'" class="card" :style="style" :class="cardClass" href="#">
      <span class="rank" v-if="cardRank">{{ cardRank }}</span>
      <span class="suit" v-if="cardRank">{{ cardSuit }}</span>
      {{ !cardRank && "*" || "" }}
    </component>
  </script>
  <script id="card">
    const Card = {
      template: '#card',
      props: ['data', 'tag'],
      computed: {
        style() { return this.data.style || "" },
        face() { return this.data.face || this.data.data || { value: 0  } },
        cardClass() { return this.face.value && ["rank-" + this.face.value.toLowerCase(), suit(this.face.suit)] || "back" },
        cardRank() { return this.face.value },
        cardSuit() { return suitCode(this.face.suit) },
      },
      mounted() { !this.$store.state.meta[this.data.id] && this.updateMeta() },
      // update card pos when window resized
      created() { window.addEventListener("resize", this.updateMeta) },
      destroyed() { window.removeEventListener("resize", this.updateMeta) },
      methods: {
        updateMeta() {
          if (!this.$el.getBoundingClientRect) { return }
          const rect = this.$el.getBoundingClientRect()
          this.$store.commit("setMeta", { id: this.data.id, data: { x: rect.left, y: rect.top } })
        }
      }
    }
  </script>

  <script type="text/x-template" id="player-board">    
    <div class="player-board" :class="tag">
      <div v-if="player" :id="player.id">
        <div id="title" class="text-center title" :class="tag">
          <v-btn rounded color="green" dark>{{ player.id }}</v-btn>
          <v-icon v-if="!player.connected">mdi-wifi-off</v-icon>
        </div>
        <div class="card-slot trash" :class="tag">
          <ul :id="player.props.trash" class="deck" style="height: 0px">
            <transition-group @enter="animateSlotEnter">
              <li v-for="card in playerTrash" :key="card.id">
                <card :data="card" style="opacity: 0" />
              </li>
            </transition-group>
          </ul>
        </div>
        <div class="card-slot" :class="tag" :style="transform +'; '+ center">
          <ul :id="player.props.hand" :class="pos ? 'hand' : 'hand my'">
            <transition-group @enter="animateSlotEnter">
              <li v-for="card in playerHand" :key="card.id" @click="play(card.id)">
                <card :data="card" :tag="cardActions(card.id).length && 'a'"/>
              </li>
            </transition-group>
          </ul>
        </div>
        <div :id="player.props.cardSlot" class="card-slot" :class="otag" :style="'z-index: ' + zIndex">
          <ul :id="player.props.cardSlot" class="deck">
            <transition-group @enter="animateSlotEnter">
              <li v-for="card in cardSlot" :key="card.id">
                <card :data="card" />
              </li>
            </transition-group>
          </ul>
        </div>
        <div class="bid text-center" :class="timerPos" v-if="player.bid >= 0">
          <v-chip class="ma-0" dark color="green" label>{{ player.bid }}</v-chip>
          <v-chip class="ma-0" dark color="blue" label>{{ player.tricks < 0 ? "" : player.tricks }}</v-chip>
        </div>
        <div class="joker text-center" :class="timerPos" v-if="player.joker.suit >= 0">
          <v-avatar color="black" v-if="jokerSuit">
            <v-icon dark>
              {{ jokerSuit }}
            </v-icon>
          </v-avatar>
          <v-chip class="ma-0" dark color="orange" label>{{ jokerLable }}</v-chip>
        </div>
        <div v-if="timer >= 1" class="timer" :class="timerPos">
          <v-progress-circular
            :rotate="-90"
            :size="50"
            color="teal"
            :value="timer/maxTimer*100"
          >
            {{ timer }}
          </v-progress-circular>
        </div>
        <div v-if="player.suit >= 0" class="player-suit">
          <v-avatar :color="color" size="48">
            <span class="white--text headline">{{ suitCode }}</span>
          </v-avatar>
        </div>
      </div>
      <div v-if="!player && player !== null" :class="tag" class="card-slot">
        <v-icon size="60" @click="placeAction">mdi-help-circle-outline</v-icon>
        <v-btn @click="addbot">add bot</v-btn>
      </div>
    </div>
  </script>
  <script id="player-board">
    const PlayerBoard = {
      template: '#player-board',
      data: () => ({
        maxTimer: -1,
        zIndex: 10,
      }),
      props: ['pos'],
      computed: {
        ...Vuex.mapGetters(["me", "objectProp", "objectItemsObject", "players", "playersList"]),
        playerIndex() { return this.playersList[Number(this.pos)] },
        player() { return this.players && this.players.find((p) => p.index === this.playerIndex) },
        playerHand() {
          if (this.player === this.me) {
            const cardRank = ["A", "K", "Q", "J", "10", "9", "8", "7", "6"]
            const cardPos = ({ face = {} }) => face.suit * 10 + cardRank.indexOf(face.value)
            const cards = this.objectItemsObject(this.me.props.hand)
            return cards.sort((c1, c2) => cardPos(c1) - cardPos(c2))
          } else {
            return this.player && this.objectItemsObject(this.player.props.hand) || []
          }
        },
        playerTrash() { return this.objectItemsObject(this.player.props.trash) },
        suitCode() { return suitCode(this.player.suit) },
        cardSlot() { 
          return this.player && this.objectItemsObject(this.player.props.cardSlot) || []
        },
        timer() {
          return this.player && this.objectProp(this.player, "timer").value || -1
        },
        tag() {
          return ['bottom', 'left', 'top', 'right'][this.pos]
        },
        otag() {
          return ['top', 'right', 'bottom', 'left'][this.pos]
        },
        timerPos() {
          return ['right t180', 't260', 'right t180', 'right t260'][this.pos]
        },
        color() {
          return this.player.suit > 1 ? 'red' : 'black'  
        },
        transform() {
          return ['transform: scale(1.5);', 'transform: rotate(0deg)', '', 'transform: rotate(-0deg)'][this.pos]
        },
        center() {
          const num = this.playerHand.length
          return ["right: " + num * 35 + "px", "", "", "right: " + num * 20 + "px"][this.pos]
        },
        jokerSuit() {
          return ["mdi-cards-spade", "mdi-cards-club", "mdi-cards-heart", "mdi-cards-diamond"][this.player.joker.suit]
        },
        jokerLable() {
          if (this.jokerSuit >= 4) {
            return this.player.joker.higher ? "Джокер сверзу" : "Джокер снизу"
          } else {
            return this.player.joker.higher ? "высшие" : "пусть берут"
          }
        },
      },
      watch: {
        timer(value) {
          this.maxTimer = Math.max(this.maxTimer, value)
        },
        cardSlot: {
          handler(value) {
            if (value.length) {
              this.zIndex = this.players.filter((p) => 
                this.objectItemsObject(p.props.cardSlot).length).length * 10
            } else {
              this.zIndex = 10
            }
          },
          deep: true
        }
      },
      methods: {
        placeAction() {
          this.$store.state.send("place", this.playersList[Number(this.pos)])
        },
        addbot() {
          this.$store.state.send("addbot", this.playersList[Number(this.pos)])
        },
        cardActions(cardId) {
          const actions = this.me && Object.values(this.me.actions || {}) || []
          return actions.filter(action => action.data && action.data.objectId === cardId)
        },
        play(cardId) {
          const possibleActions = this.cardActions(cardId)
          if (possibleActions.length === 1) {
            this.$store.dispatch("execAction", possibleActions[0].id)
          } else if (possibleActions.length > 1) {
            // this.$store.commit("selectCard", cardId)
            this.$store.commit("setMeta", { id: this.$store.getters.board.id, data: { selectedCardId: cardId } })
          }
        },
        animateSlotEnter(el, done) {
          const { left, top } = el.firstChild.getBoundingClientRect()
          this.$store.dispatch("animate", { el: el.firstChild, x: left, y: top, r: 180, done })
        },
        animateEnter(el, done) {
          const { left, top } = el.getBoundingClientRect()
          this.$store.dispatch("animate", { el, x: left, y: top, r: 180, done })
        },
      }
    }
  </script>

  <script type="text/x-template" id="loader">
    <v-dialog v-model="loading" persistent width="120">
      <v-card>
        <v-card-text class="text-xs-center">
          <v-progress-circular :size="70" indeterminate class="secondary--text"/>
        </v-card-text>
      </v-card>
    </v-dialog>
  </script>
  <script id="loader">
    const Loader = {
      template: "#loader",
      computed: {
        loading: {
          get() { return this.$store.state.loading },
          set(value) { this.$store.commit("setLoading", value) }
        }
      }
    }
  </script>

  <script type="text/x-template" id="last-trick-dialog">
    <v-dialog v-model="dialog" width="320">
      <v-card flat class="py-12 d-flex justify-center">
        <v-card-text>
          <v-row >
            <v-col cols="12" align="center" justify="center" >
              <div class="card">
                <span class="rank">{{ cardRank(2) }}</span>
                <span class="suit">{{ cardSuit(2) }}</span>
              </div>
            </v-col>
          </v-row>
          <v-row>
            <v-col cols="6" align="center" justify="center" >
              <div class="card">
                <span class="rank">{{ cardRank(1) }}</span>
                <span class="suit">{{ cardSuit(1) }}</span>
              </div>
            </v-col>
            <v-col cols="6" align="center" justify="center" >
              <div class="card">
                <span class="rank">{{ cardRank(3) }}</span>
                <span class="suit">{{ cardSuit(3) }}</span>
              </div>
            </v-col>
          </v-row>
          <v-row   >
            <v-col cols="12" align="center" justify="center" >
              <div class="card">
                <span class="rank">{{ cardRank(0) }}</span>
                <span class="suit">{{ cardSuit(0) }}</span>
              </div>
            </v-col>
          </v-row>
        </v-card-text>
      </v-card>
    </v-dialog>
  </script>
  <script id="last-trick-dialog">
    const LastTrickDialog = {
      template: "#last-trick-dialog",
      computed: {
        ...Vuex.mapGetters([ "board", "playersList" ]),
        lastTrick() { return (i) => this.board && this.board.lastTrick[this.playersList[i]] || {} },
        cardRank() { return (i) => this.lastTrick(i).value },
        cardSuit() { return (i) => suitCode(this.lastTrick(i).suit) },
        dialog: {
          get() { return this.$store.state.lastTrickDialog },
          set(value) { this.$store.commit("setLastTrickDialog", value) }
        },
      }
    }
  </script>

  <script type="text/x-template" id="select-trump-dialog">
    <v-dialog v-model="dialog" persistent width="320">
      <v-card flat class="py-12">
        <v-card-text>
          <v-row align="center" justify="center" >
            <v-col cols="12">
              <p class="text-center">
                Выберите козырь
              </p>
            </v-col>
            <v-btn-toggle>
              <v-btn v-for="action of actions" :key="action.id" @click="execAction(action.id)">
                <v-icon>{{ action.icon }}</v-icon>
              </v-btn>
            </v-btn-toggle>
          </v-row>
        </v-card-text>
      </v-card>
    </v-dialog>
  </script>
  <script id="select-trump-dialog">
    const SelectTrump = {
      template: "#select-trump-dialog",
      computed: {
        ...Vuex.mapGetters([ "me" ]),
        actions() {
          const actions = this.me && Object.values(this.me.actions || {}) || []
          const icons = ["mdi-cards-spade", "mdi-cards-club", "mdi-cards-heart", "mdi-cards-diamond", "mdi-xamarin-outline"]
          return actions.filter(({ name }) => name === "setTrump").map((a) => ({ id: a.id, icon: icons[a.data] }))
        },
        dialog: {
          get() { return this.$store.getters.dialog("selectTrump") },
          set(value) {  }
        },
      },
      methods: {
        execAction(actionId) {
          this.$store.dispatch("execAction", actionId)
        }
      }
    }
  </script>

  <script type="text/x-template" id="select-joker-dialog">
    <v-dialog v-model="showDialog" persistent width="320">
      <v-card flat class="py-12">
        <v-card-text>
          <v-row align="center" justify="center">
            <v-col cols="12">
              <p class="text-center">
                Выберите как играть джокером
              </p>
            </v-col>
            <p class="text-center" v-if="firstCard">
              Высшие 
            </p>
            <v-btn-toggle>
              <v-btn v-for="action of actions" :key="action.id" v-if="action.higher" @click="execAction(action.id)">
                <v-icon v-if="action.icon">{{ action.icon }}</v-icon>
                <span v-else>Джокер старшая карта </span>
              </v-btn>
            </v-btn-toggle>
            <br>
            <p class="text-center" v-if="firstCard">
              Пусть берут
            </p>
            <v-btn-toggle>
              <v-btn v-for="action of actions" :key="action.id" v-if="!action.higher" @click="execAction(action.id)">
                <v-icon v-if="action.icon" >{{ action.icon }}</v-icon>
                <span v-else>Джокер младшая карта </span>
              </v-btn>
            </v-btn-toggle>
          </v-row>
        </v-card-text>
      </v-card>
    </v-dialog>
  </script>
  <script id="select-joker-dialog">
    const SelectJoker = {
      template: "#select-joker-dialog",
      computed: {
        ...Vuex.mapGetters([ "me", "dialog" ]),
        actions() {
          const actions = this.me && Object.values(this.me.actions || {}) || []
          const icons = ["mdi-cards-spade", "mdi-cards-club", "mdi-cards-heart", "mdi-cards-diamond"]
          return actions.filter(({ name }) => name === "setJoker").map(({ id, data }) => ({ id: id, higher: data.higher, icon: icons[data.suit] }))
        },
        firstCard() { return this.dialog("selectFirstCardJoker") },
        showDialog: {
          get() { return this.dialog("selectJoker") || this.dialog("selectFirstCardJoker") },
          set(value) {  }
        },
      },
      methods: {
        execAction(actionId) {
          this.$store.dispatch("execAction", actionId)
        }
      }
    }
  </script>

  <script type="text/x-template" id="select-bid-dialog">
    <v-dialog v-model="dialog" persistent width="320">
      <v-card flat class="py-12" >
        <v-card-text>
          <v-row align="center" justify="center">
            <v-col cols="12">
              <p class="text-center">
                Выберите кол-во взяток
              </p>
            </v-col>
            <v-btn-toggle>
              <v-btn v-for="(action,i) of actions" :key="action.id" v-if="i < 5" @click="execAction(action.id)">
                <v-icon >{{ action.bid }}</v-icon>
              </v-btn>
            </v-btn-toggle>
            <v-btn-toggle>
              <v-btn v-for="(action,i) of actions" :key="action.id" v-if="i > 4" @click="execAction(action.id)">
                <v-icon>{{ action.bid }}</v-icon>
              </v-btn>
            </v-btn-toggle>
          </v-row>
        </v-card-text>
      </v-card>
    </v-dialog>
  </script>
  <script id="select-bid-dialog">
    const SelectBid = {
      template: "#select-bid-dialog",
      computed: {
        ...Vuex.mapGetters([ "me" ]),
        actions() {
          const actions = this.me && Object.values(this.me.actions || {}) || []
          return actions.filter(({ name }) => name === "setBid").map((a) => ({ id: a.id, bid: a.data }))
        },
        dialog: {
          get() { return this.$store.getters.dialog("selectBid") },
          set(value) {  }
        },
      },
      methods: {
        execAction(actionId) {
          this.$store.dispatch("execAction", actionId)
        }
      }
    }
  </script>

  <script type="text/x-template" id="game-layout"> 
    <div id="game-container">   
      <div id="game-table" class="playingCards faceImages">
        <div class="game-board" v-if="board && board.scene !== 'init'">
          <deck class="game-deck"></deck>
          <trump-slot class="game-trump"></trump-slot>
          <div class="game-trump" v-if="trumpIcon" style="top: 40px">
            <v-avatar color="black">
              <v-icon dark>
                {{ trumpIcon }}
              </v-icon>
            </v-avatar>
          </div>
        </div>
        <player-board pos=0></player-board>
        <player-board pos=1></player-board>
        <player-board pos=2></player-board>
        <player-board pos=3></player-board>
        <div id="lastTrick" class="left bottom" style="position: absolute" v-if="lastTrick.length">
          <v-btn rounded color="blue" dark @click="showLastTrick()">Последняя взятка</v-btn>
        </div>
        <div id="showScore" class="right bottom" style="position: absolute" v-if="scene === 'gameRound'">
          <v-btn rounded color="blue" dark @click="showScore()">Счет</v-btn>
        </div>
        <select-trump-dialog />
        <select-bid-dialog />
        <select-joker-dialog />
        <game-score />
        <last-trick-dialog />
      </div>
    </div>
  </script>
  <script id="game-layout">
    const MIN_WIDTH = 650;
    const MAX_WIDTH = 1500;
    const MIN_HEIGHT = 750;
    const MAX_HEIGHT = 1100;

    const GameLayout = {
      template: '#game-layout',
      props: ["id"],
      computed: {
        ...Vuex.mapGetters([ "players", "board", "me", "objectProp" ]),
        trumpIcon() { 
          const icons = ["mdi-cards-spade", "mdi-cards-club", "mdi-cards-heart", "mdi-cards-diamond", "mdi-xamarin-outline"]
          const trump = this.objectProp(this.board, "trump")
          return icons[trump.suit] 
        },
        lastTrick() { return this.board && this.board.lastTrick.filter(({ suit }) => suit >= 0) || [] },
        scene() { return this.board && this.board.scene || "" },
      },
      watch: {
        id(val) {
          console.log(id)
        }
      },
      methods: {
        showLastTrick() {
          this.$store.commit("setLastTrickDialog", true)
        },
        showScore() {
          this.$store.commit("showScore", true)
        },
        resize() {
          // get parent element size
          const { clientWidth: width, clientHeight: height } = this.$el
          
          // calculate scale for width & height 
          let scaleX = width / (width < MIN_WIDTH && MIN_WIDTH || width > MAX_WIDTH && MAX_WIDTH || width)
          let scaleY = height / (height < MIN_HEIGHT && MIN_HEIGHT || height > MAX_HEIGHT && MAX_HEIGHT || height)
        
          // adjust scale for width and height
          scaleX = Math.min(scaleX, height / MIN_HEIGHT)
          scaleY = Math.min(scaleY, width / MIN_WIDTH)
          
          // select scale
          const scale = Math.abs(scaleX - 1) > Math.abs(scaleY - 1) ? scaleX : scaleY

          // calculate scaled width & height
          var elWidth = Math.min(Math.max(width / scale, MIN_WIDTH), MAX_WIDTH)
          var elHeight = Math.min(Math.max(height / scale, MIN_HEIGHT), MAX_HEIGHT)

          // update #game-table inline style
          const { style } = this.$el.lastChild
          // this.$store.commit("setScale", { scale })
          if (!style) { return }
          style.width = scale !== 1 && elWidth + "px" || "",
          style.height = scale !== 1 && elHeight + "px" || "",
          style.transform = scale !== 1 && "scale(" + scale + ")" || ""
          style.transformOrigin = "top left"
        },
      },
      async mounted() {
        const roomId = this.$route.params.id
        if (this.$route.params.id !== this.$store.state.roomId) {
          try {
            console.log("Try to reconnect", roomId)
            await this.$store.dispatch("reconnect", roomId)
            console.log("Reconnected!")
          } catch (error) {
            console.log("Cannot reconnect room", error)
            this.$router.push({ path: "/" })
            return 
          }          
        }
        window.addEventListener("resize", this.resize) 
        this.resize()
      },
    }
  </script>

  <script type="text/x-template" id="create-game">    
    <v-container>
      <h1>Создать комнату</h1>
      <v-row class="mb-6" justify="center" no-gutters>

          <v-col lg="12">

            <v-text-field v-model="name" label="Название комнаты"></v-text-field>
            <v-slider v-model="bet" :label="betText" step="100" min="100" max="1000"></v-slider>
            <v-text-field v-model="password" label="Password"></v-text-field>
          
            <v-switch v-model="autoPlay" label="Автоход по таймауту"></v-switch>
            <v-slider v-model="timer" :label="timerText" step="1" min="1" max="30"></v-slider>

            <v-btn class="ma-2" :loading="loading" :disabled="loading || error" @click="create()">
              Создать
            </v-btn>

            <v-btn class="ma-2" to="/">
              Отмена
            </v-btn>

          </v-col>

      </v-row>
    </v-container>
  </script>
  <script id="create-game">
    const CreateGame = {
      template: '#create-game',
      data: () => ({
        name: "",
        bet: 0,
        password: '',
        loading: false,
        autoPlay: false,
        timer: 15,
      }),
      computed: {
        error() { return !this.name },
        betText() { return "Ставка: " + this.bet },
        timerText() { return "Время на ход: " + this.timer },
      },
      methods: {
        async create() {
          const { name, bet, password, autoplay, timer } = this.$data
          await this.$store.dispatch("createRoom", { bet, password, autoplay, timer })
          const roomId = this.$store.state.roomId
          if (roomId) {
            this.$router.push({ path: `/game/${roomId}`})
          }
        }
      }
    }
  </script>

  <script type="text/x-template" id="game-score">
    <v-dialog v-model="dialog" width="600">
      <v-container>
        <v-row no-gutters >
          <v-col cols="1">
          </v-col>
          <v-col v-for="p in 4" :key="p">
            <v-card
              class="pa-2"
              outlined
              tile
            >
              <v-chip
                color="secondary lighten-2"
                class="ml-0 mr-2"
              >
              {{ p }}
              </v-chip>
              {{ playerName(p) }}
            </v-card>
          </v-col>

        </v-row>
        <v-row no-gutters v-for="r in 29" :key="r" align="center">
          <v-col cols="1"  >
            <span class="float-right pr-4">{{ rowLable(r) }}</span>
          </v-col>
          <v-col v-for="p in 4" :key="p" >
            <v-card
              class="pa-2"
              outlined
              tile
              :class="showChip(r) ? '' : 'grey lighten-5'"
            >
              <v-card-text class="pt-0 pb-0 text-center">
                <v-chip
                  v-if="showChip(r)"
                  color="green lighten-4"
                  class="ml-0 mr-2 black--text float-left"
                  label
                  small 
                >
                  {{ rowDataChip(r,p) }}
                </v-chip>
          
                <span :class="showChip(r) ? '' : 'font-weight-bold' ">{{ rowData(r,p) }}</span>
              </v-card-text>
            </v-card>
          </v-col>
        </v-row>
      </v-container>
    </v-dialog>
  </script>
  <script id="game-score">
  const GameScore = {
    template: '#game-score',
    computed: {
      ...Vuex.mapGetters(["board", "players"]),
      dialog: {
        get() { return (this.board && this.board.scene === "gameScore") || this.$store.state.showScore },
        set(value) { this.$store.commit("showScore", value)  }
      },
      scroreRows() {
        const rows = []
        for (let i = 0; i < this.board.score.length; i += 12) {
          rows.push(this.board.score.slice(i, i+12))
        }
        return rows
      }
    },
    methods: {
      playerName(p) {
        if (!this.players[p-1]) { return "" }
        return this.players[p-1].id
      },
      shift(index) {
        let shift = 0
        for (let i of [9, 14, 23, 28, 29]) {
          shift += index >= i ? 1 : 0
        }
        return shift
      },
      showChip(index) {
        return ![9, 14, 23, 28, 29].includes(index)
      },
      rowLable(index) {
        if ([9, 14, 23, 28, 29].includes(index)) {
          return ""
        }
        if (index < 9) {
          return index
        } else if (index < 14) {
          return 9
        } else if (index < 23) {
          return Math.abs(index - 23)
        } else {
          return 9
        }
      },
      rowDataChip(index, player) {
        if ([9, 14, 23, 28, 29].includes(index) || !this.board) {
          return ""
        }
        return this.board.score[(index-1)*12+(player-1)*3]
      },
      rowData(index, player) {
        if (!this.board) { return "" }

        const calcScore = (r, p) => {
          const score = this.board.score[r*12+p*3 + 2]
          return score === undefined ? "." : score
        }

        const calcTotal = (r0, r1, p) => {
          if (calcScore(r1, p) === ".") { return "." }
          let total = 0
          for (let r = r0; r <= r1; r++) {
            total += calcScore(r, p) || 0
          }
          return total
        }

        switch (index) {
          case 9: return calcTotal(0, 7, player-1)
          case 14: return calcTotal(8, 11, player-1)
          case 23: return calcTotal(12, 19, player-1)
          case 28: return calcTotal(20, 23, player-1)
          case 29: return calcTotal(0, 23, player-1)
        
          default:
            return calcScore(index - this.shift(index) - 1, player - 1)
        }        
      }
    }
  }
  </script>

  <script id="magx">
    const { host, port, protocol } = window.document.location
    var client = new MagX.Client({ address: host.replace(/:.*/, ''), port, secure: protocol === "https:" })

    const suit = suitId => (["spades", "clubs", "hearts", "diams"][suitId] || "")
    const suitCode = suitId => (["\u2660", "\u2663", "\u2665", "\u2666"][suitId] || "")
  </script>

  <script id="store">
  
    let settings = {
      waitTime: 30,
      turnTime: 30,
      reconnectionTimeout: 30,
      reconnectionLimit: 5,
      reconnectionDelay: 15
    }

    const store = new Vuex.Store({
      strict: true,
      state: {
        error: "",
        loading: false,
  
        token: "",
        // state from patches
        clients: {},
        objects: {},
        boardId: "",
        // meta for objects data
        meta: {},
        // from client
        clientId: "",
        // from room
        roomId: "",
        send: null,
        leave: null,
        rooms: [],
        lastTrickDialog: false,
        showScore: false,
      },
      getters: {
        dialog: ({ dialog }, { me }) => (name) => me && me.dialog === name || false,
        // get object by id
        object: ({ objects }) => (id) => objects[id] || null,
        // get meta by id
        objectMeta: ({ meta }) => (id) => meta[id] || null,

        // get property object
        objectProp: ({ }, { object }) => (obj, id) => obj && object(obj.props[id]) || null,

        // get list of items id
        objectItems: ({ }, { object }) => (id) => object(id) && object(id).items || [],
        // get list of items objects
        objectItemsObject: ({ }, { objectItems, object }) => (id) => objectItems(id).map(itemId => object(itemId)),

        // get client's player
        me: ({ clients, clientId }, { object }) => clientId && clients[clientId] && object(clients[clientId].playerId) || null,
        // get board
        board: ({ boardId }, { object }) => object(boardId),
        // get list of players
        players: ({ clients, objects }, { object, board }) => {
          return Object.values(objects).filter((o) => o.type === "JokerPlayer").sort((a,b) => a.index - b.index)
        },
        playersList: ({}, { me }) => {
          const result = [0,1,2,3]
          if (!me) { return result }
          const index = result.indexOf(me.index)
          if (index > 0) {
            result.push(...result.splice(0, index))
          }
          return result
        },
      },
      mutations: {
        setLoading(state, value) { state.loading = value },
        setError(state, value) { state.error = value },
        setToken(state, value) { state.token = value },
        setRoom(state, room) {
          state.clientId = room.client.auth.id
          state.roomId = room.id
          state.leave = () => room.leave()
          state.send = (type, data) => room.send(type, data)
        },
        showScore(state, value) { state.showScore = value },
        setRooms(state, rooms) { state.rooms = rooms },
        setDialog(state, { name, value }) { state.dialog = { name: value } },
        setLastTrickDialog(state, value) { state.lastTrickDialog = value },
        updateRoom(state, { roomId, data }) {
          const index = state.rooms.findIndex((room) => room.id === roomId)
          if (data === null) {
            state.rooms.splice(index, 1)
          } else {
            if (index >= 0) {
              Vue.set(state.rooms, index, data)
            } else {
              state.rooms.push(data)
            }
          }
        },
        setState(state, snapshot) {
          Object.keys(snapshot).forEach((key) => Vue.set(state, key, snapshot[key]))
        },
        setMeta: (state, { id, data }) => {
          Vue.set(state.meta, id, data)
        },
        setMetaProp: (state, { id, prop, data }) => {
          if (state.meta[id]) {
            Vue.set(state.meta[id], prop, data)
          } else {
            Vue.set(state.meta, id, { [prop]: data })
          }
        },
        add(state, { value, key, path }) {
          let obj = state
          path.forEach(id => obj = obj[id])
          if (Array.isArray(obj) && +key) {
            obj.splice(+key, 0, value)
          } else {
            Vue.set(obj, key, value) // set value
          }
        },
        replace(state, { value, key, path }) {
          let obj = state
          path.forEach(id => obj = obj[id])
          if (Array.isArray(obj) && +key) {
            Vue.set(obj, +key, value) // update array value
          } else {
            Vue.set(obj, key, value) // update object value
          }
        },
        remove(state, { path, key }) {
          let obj = state
          path.forEach(id => obj = obj[id])
          if (Array.isArray(obj) && +key) {
            obj.splice(+key, 1)
          } else {
            Vue.delete(obj, key)
          }
        },
      },
      actions: {
        async verifyToken({ commit, dispatch }, token) {
          if (!token) { return }
          commit("setLoading", true)
          try {
            console.log("verify token", token)
            const auth = await client.verify(token)
            if (!auth) {
              throw new Error()
            } else {
              commit("setState", { token, loading: false })
            }
            return dispatch("joinLobby")
          } catch (error) {
            commit("setState", { token: "", loading: false })
            router.push({ path: "/login" })
          }
        },
        async authenticate({ commit, dispatch }, id) {
          commit("setState", { loading: true })
          try {
            const auth = await client.authenticate({ id })
            console.log("authenticate", auth)
            // commit("setProfile", auth.data)
            sessionStorage.setItem("token", auth.token)
            commit("setState", { loading: false, token: auth.token })
            return dispatch("joinLobby")
          } catch (error) {
            console.log("Error", error)
            commit("setState", { token: "", loading: false })
          }
        },
        async joinLobby({ commit, dispatch }) {
          commit("setLoading", true)
          try {
            const rooms = await client.getRooms("jokerLobby")
            const lobby = rooms.length ? await client.joinRoom(rooms[0].id) : await client.createRoom("jokerLobby")
          
            console.log("joind lobby")
            return dispatch("initLobbyHandlers", lobby)
          } catch (error) {
            commit("setLoading", false)
            console.log("Error", error)
          }
        },
        initLobbyHandlers({ commit, dispatch }, lobby) {
          lobby.onMessage("rooms", async (roomsList) => {
            commit("setRooms", roomsList)
          })
          lobby.onMessage("room_update", async (update) => {
            commit("updateRoom", update)
          })
          lobby.onMessage("error", async (data) => {
            console.log(data)
          })
          commit("setLoading", false)
        },
        /** 
         * server events
        */

        addBot({ state }) {
          state.send("addbot")
        },

        execAction({ state, getters, commit }, actionId) {
          commit("setMeta", { id: getters.board.id, data: { selectedCardId: null } })
          state.send("action", { actionId })
        },

        send({ state }, { type, data }) {
          state.send(type, data)
        },

        async leave({ state }) {
          state.send("surrender")
        },

        /**
         * Animation
        */
        animate({ state, commit }, { el, x, y, r, done }) {
          const meta = state.meta[el.id]
          if (!meta) { return }
          r = r || 180
          if (Math.abs(meta.x - x) + Math.abs(meta.y - y) > 100) {
            r = 0
            TweenMax.from(el, 0.5, { x: meta.x - x, y: meta.y - y, rotation: r, opacity: 1, onComplete: done })
          }
          commit("setMeta", { id: el.id, data: { x, y } })
        },

        /**
         * Magx API
        */

        async createRoom({ dispatch }, options) {
          room = await client.createRoom('joker', options)
          console.log("Room created", room)
          await dispatch("initRoomHandlers", room)
        },

        async joinRoom({ dispatch }, { roomId, password }) {
          room = await client.joinRoom(roomId, { password })
          dispatch("initRoomHandlers", room)
        },

        async reconnect({ dispatch }, roomId) {
          const timer = setTimeout(() => {
            Promise.reject()
          }, 1000)
          room = await client.reconnect(roomId)
          clearTimeout(timer)
          dispatch("initRoomHandlers", room)
        },
        // init room handlers
        initRoomHandlers({ commit, dispatch }, room) {
          commit("setRoom", room)

          // save roomId
          sessionStorage.setItem('roomId', room.id)

          // handle messages from server
          room.onMessage("log", (data) => {
            console.log(data)
          })

          room.onPatch(({ op, value, path }) => {
            // console.log("onPatch", { op, value, path })
            path = path.substr(1).split("/")
            commit(op, { value, key: path.pop(), path })
          })

          room.onSnapshot((snapshot) => {
            // console.log("onSnapshot", snapshot)
            commit("setState", snapshot)
          })

          room.onLeave(() => {
            // TODO
          })
        }
      }
    })
  </script>

  <script id="router">
    const router = new VueRouter({
      mode: "history",
      routes: [
        { path: '/', component: Main },
        { path: '/login', component: Login },
        { path: '/game/create', component: CreateGame },
        { path: '/game/:id', component: GameLayout, props: true },
      ]
    })

    router.beforeEach(async (to, from, next) => {
      if (to.path !== "/login" && !store.state.token) {
        const token = sessionStorage.getItem("token")
        if (!token) { return next({ path: '/login' }) }
        try {
          await store.dispatch("verifyToken", token)
          next()
        } catch (error) {
          next({ path: '/login' })
        }
      } else {
        next()
      }
    })
  </script>

  <script id="vue">
    Vue.component('appbar', AppBar)
    Vue.component('loader', Loader)
    Vue.component('layout', Layout)
    Vue.component('error', ErrorMessage)

    Vue.component('deck', Deck)
    Vue.component('card', Card)
    Vue.component('player-board', PlayerBoard)
    Vue.component('trump-slot', TrumpSlot)
    Vue.component('select-trump-dialog', SelectTrump)
    Vue.component('select-joker-dialog', SelectJoker)
    Vue.component('select-bid-dialog', SelectBid)
    Vue.component('last-trick-dialog', LastTrickDialog)
    Vue.component('game-score', GameScore)

    new Vue({
      el: '#app',
      router,
      store,
      vuetify: new Vuetify({
        theme: {
          themes: {
            light: {
              primary: "#388E3C", // "green darken-2"
              secondary: "#512DA8", // "deep-purple darken-2"
              accent: "#FFD600", // "yellow accent-4"
            },
          },
        },
      }),
    })
  </script>

</body>

</html>